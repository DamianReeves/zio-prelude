<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>NonEmptyList · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`NonEmptyList` represents a `List` that is guaranteed not to be empty."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="NonEmptyList · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`NonEmptyList` represents a `List` that is guaranteed not to be empty."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class=""><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Functional Data Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Functional Data Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/">Summary</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/equivalence">Equivalence</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/nonemptylist">NonEmptyList</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/these">These</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/validation">Validation</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/zset">ZSet</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionaldatatypes/zvalidation">ZValidation</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">NonEmptyList</h1></header><article><div><span><p><code>NonEmptyList</code> represents a <code>List</code> that is guaranteed not to be empty.</p>
<p>This is useful to allow more accurate domain modeling in situations where we know a collection is not empty.</p>
<p>For example, we might be handling a collection of errors. If an error has occurred at all then we know the collection is not empty.</p>
<p>However, if we are working with a collection type from the Scala standard library such as <code>List</code>, <code>Vector</code>, or <code>Iterable</code> then the Scala compiler does not know that. It will force us to handle the case where the collection is empty even though we know that cannot occur.</p>
<p>Or perhaps we are implementing a batched API and need to handle a collection of requests. We know the collection is not empty or we would not have been called at all, but now we have to handle the case of an empty collection.</p>
<p>Sometimes there are sensible defaults in these cases, but other times we are forced to resort to potentially unsafe operators like <code>head</code> or to throw exceptions in branches of logic we know should never occur. This wastes developer time, makes code harder to understand, and encourages bad coding practices.</p>
<p>To avoid these problems we want a data type that is specific enough to describe at the type level what we know to be true, in this case that a collection is not empty.</p>
<p>We can try to represent this using the <code>::</code> case of <code>List</code> from the Scala standard library but unfortunately <code>::</code> itself has extremely poor ergonomics. It is hard to construct <code>::</code> values and it is easy for operators to forget the more specific type.</p>
<p>This is where <code>NonEmptyList</code> comes in.</p>
<p>A <code>NonEmptyList</code> looks like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NonEmptyList</span>[+<span class="hljs-type">A</span>]</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NonEmptyList</span> </span>{
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span>[<span class="hljs-type">A</span>](<span class="hljs-params">head: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">NonEmptyList</span>[<span class="hljs-type">A</span>]</span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span>[<span class="hljs-type">A</span>](<span class="hljs-params">head: <span class="hljs-type">A</span>, tail: <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">NonEmptyList</span>[<span class="hljs-type">A</span>]</span>
}
</code></pre>
<p>We can see that <code>NonEmptyList</code> looks very similar to <code>List</code> except that there is no <code>Nil</code> case. A <code>NonEmptyList</code> is either a <code>Single</code> with a single value of type <code>A</code> or a <code>Cons</code> with a value of type <code>A</code> and a <code>NonEmptyList</code> of further values of type <code>A</code>.</p>
<p>Generally you should just be able to use higher level operators on <code>NonEmptyList</code> but if you ever want to implement your own operators on <code>NonEmptyList</code> you can do so by pattern matching on a <code>NonEmptyList</code> just like you would on a <code>List</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="constructing-nonemptylist-values"></a><a href="#constructing-nonemptylist-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructing NonEmptyList Values</h2>
<p>The easiest way to construct a <code>NonEmptyList</code> is with the <code>apply</code> operator.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NonEmptyList</span>[+<span class="hljs-type">A</span>]</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NonEmptyList</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>, as: <span class="hljs-type">A</span>*): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>] =
    ???
}
</code></pre>
<p>If we already have another collection type we can convert it into a <code>NonEmptyList</code> using the <code>fromIterableOption</code> operator.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NonEmptyList</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromIterableOption</span></span>[<span class="hljs-type">A</span>](as: <span class="hljs-type">Iterable</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>]] =
    ???
}
</code></pre>
<p>Notice that <code>fromIterableOption</code> returns an <code>Option[NonEmptyList[A]]</code> because the original collection might be empty and so we might not be able to construct a <code>NonEmptyList</code> from it.</p>
<p>If we know the collection is not empty we can use the <code>fromIterable</code> operator and provide the first element of the collection to establish that it is not empty.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NonEmptyList</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromIterable</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>, as: <span class="hljs-type">Iterable</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>] =
    ???
}
</code></pre>
<p>We can also construct a <code>NonEmptyList</code> from the <code>::</code> case of a <code>List</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NonEmptyList</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromCons</span></span>[<span class="hljs-type">A</span>](as: ::[<span class="hljs-type">A</span>]): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>] =
    ???
}
</code></pre>
<p>This is useful if we already have a <code>::</code> value, for example from a <code>ZIO</code> operator like <code>ZIO.validate</code> that returns <code>::[E]</code> if it fails.</p>
<p>In addition to these operators for constructing <code>NonEmptyList</code> values from other values there are a couple of operators that are useful for building up <code>NonEmptyList</code> values.</p>
<p>The <code>single</code> operator lets us construct a <code>NonEmptyList</code> from a single value. The <code>cons</code> operator lets us construct a new <code>NonEmptyList</code> from an existing <code>NonEmptyList</code> and a new head value.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NonEmptyList</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cons</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>, as: <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>] =
    ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">single</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>] =
    ???
}
</code></pre>
<p>These operators let us build larger <code>NonEmptyList</code> values from smaller ones in recursive algorithms much like the <code>::</code> operator and <code>Nil</code> allow us to do for <code>List</code> values.</p>
<h2><a class="anchor" aria-hidden="true" id="working-with-nonemptylist-values"></a><a href="#working-with-nonemptylist-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Working With NonEmptyList Values</h2>
<p>The operators on <code>NonEmptyList</code> values are essentially the same as those on <code>List</code>. So if you know how to work with a <code>List</code> you know how to work with a <code>NonEmptyList</code>.</p>
<p>The main difference between a <code>NonEmptyList</code> and a <code>List</code> is that many operators are safe on <code>NonEmptyList</code> that are not safe on <code>List</code>.</p>
<p>For example, we would generally not consider it a good practice to call <code>head</code> on a <code>List</code> because that could throw an exception. However, it is fine to call <code>head</code> on a <code>NonEmptyList</code> because it is always guaranteed to contain at most one value.</p>
<p>Similarly, we can use <code>reduceLeft</code> or <code>reduceRight</code> to reduce the elements of a <code>NonEmptyList</code> to a summary value even though this would not be safe to do on a <code>List</code> because we know there is always at least one element.</p>
<p>The other difference between a <code>NonEmptyList</code> and a <code>List</code> is that operators on <code>NonEmptyList</code> will try to preserve the knowledge that the list is not empty whenever possible.</p>
<p>For example, the <code>map</code> operator on <code>NonEmptyList</code> looks like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NonEmptyList</span>[+<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">B</span>]
}
</code></pre>
<p>The return type is also a <code>NonEmptyList</code> because <code>map</code> transforms each element with a function but does not change the number of elements, so if the original list was not empty then we know that the resulting list is not empty.</p>
<p>However, sometimes it is not possible to preserve this information because of the nature of the operator.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NonEmptyList</span>[+<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dropWhile</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>): <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]
}
</code></pre>
<p>The <code>dropWhile</code> operator returns a <code>List[A]</code> instead of a <code>NonEmptyList[A]</code> because it could drop all of the elements of the list, resulting in a list that is empty. So we can no longer return a <code>NonEmptyList</code>.</p>
<p>The final difference between <code>NonEmptyList</code> and <code>List</code> is some additional operators are provided that take advantage of the fact that we know the list is not empty.</p>
<p>The most notable of these are <code>reduceMapLeft</code> and <code>reduceMapRight</code>, which take the place of <code>foldLeft</code> and <code>foldRight</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NonEmptyList</span>[+<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduceMapLeft</span></span>[<span class="hljs-type">B</span>](map: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(reduce: (<span class="hljs-type">B</span>, <span class="hljs-type">A</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduceMapRight</span></span>[<span class="hljs-type">B</span>](map: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(reduce: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span>
}
</code></pre>
<p>On standard collections <code>foldLeft</code> and <code>foldRight</code> are fundamental collection operators that allow us to &quot;tear down&quot; a collection to a summary value by providing an initial value to use if the collection is empty and a way to update that initial value for every element in the collection.</p>
<p>Since we know that a <code>NonEmptyList</code> contains at least one value, we don't need to provide an initial value for when the list is empty and can use the <code>reduceLeft</code> and <code>reduceRight</code> operators. However, these operators don't provide us quite the power we need in a lot of situations because they don't allow the type of the summary value to differ from the type of the elements in the collection.</p>
<p>The <code>reduceMapLeft</code> and <code>reduceMapRight</code> operators allow us to transform the first value in the <code>NonEmptyList</code> to the summary value and then combine each other value with that summary value. This is useful because it allows us to preserve the information that the collection is not empty.</p>
<p>For example, here is how we could use <code>reduceMapLeft</code> to convert a <code>NonEmptyList</code> to a <code>NonEmptyChunk</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.<span class="hljs-type">NonEmptyChunk</span>
<span class="hljs-keyword">import</span> zio.prelude.<span class="hljs-type">NonEmptyList</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toNonEmptyChunk</span></span>[<span class="hljs-type">A</span>](as: <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">NonEmptyChunk</span>[<span class="hljs-type">A</span>] =
  as.reduceMapLeft(a =&gt; <span class="hljs-type">NonEmptyChunk</span>(a))(_ appended _)
</code></pre>
<p>This would have been difficult to express with <code>foldLeft</code> because we would have had to start with an initial value that was an empty chunk and thus would have gotten back a <code>Chunk</code> instead of a <code>NonEmptyChunk</code>.</p>
<p>Of course we could have just used the <code>toNonEmptyChunk</code> operator on <code>NonEmptyList</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toNonEmptyChunk</span></span>[<span class="hljs-type">A</span>](as: <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">NonEmptyChunk</span>[<span class="hljs-type">A</span>] =
  as.toNonEmptyChunk
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="interoperability-with-scala-collections"></a><a href="#interoperability-with-scala-collections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interoperability With Scala Collections</h2>
<p>One of the great features of the <code>NonEmptyList</code> data type is its excellent integration with the Scala standard library collections framework.</p>
<p>A <code>NonEmptyList</code> is implicitly convertible into the <code>::</code> case of a <code>List</code> so anywhere you need a <code>List</code> and provide a <code>NonEmptyList</code> it will just work.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude.<span class="hljs-type">NonEmptyList</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myExistingAPI</span></span>(as: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">String</span> =
  <span class="hljs-string">"Some fancy stuff"</span>

<span class="hljs-keyword">val</span> nonEmptyList: <span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">Int</span>] =
  <span class="hljs-type">NonEmptyList</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// nonEmptyList: NonEmptyList[Int] = Cons(</span>
<span class="hljs-comment">//   head = 1,</span>
<span class="hljs-comment">//   tail = Cons(head = 2, tail = Single(head = 3))</span>
<span class="hljs-comment">// )</span>

myExistingAPI(nonEmptyList)
<span class="hljs-comment">// res2: String = "Some fancy stuff"</span>
</code></pre>
<p>This is also extremely convenient because it means all operators available on <code>List</code> are available on <code>NonEmptyList</code>.</p>
<p>For example, the <code>filter</code> operator is not implemented directly on <code>NonEmptyList</code>. But you can still filter a <code>NonEmptyList</code> because we can always view a <code>NonEmptyList</code> as a <code>List</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> filtered: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] =
  nonEmptyList.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
<span class="hljs-comment">// filtered: List[Int] = List(2)</span>
</code></pre>
<p>The return type of <code>List[Int]</code> is as specific as possible because the <code>filter</code> operator could filter out all the elements of the list and return a list that is empty.</p>
<p>Thus, <code>NonEmptyList</code> lets us work in a way that is as close as possible to being as if <code>NonEmptyList</code> was a subtype of <code>List</code>, which conceptually it is.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionaldatatypes/equivalence"><span class="arrow-prev">← </span><span>Equivalence</span></a><a class="docs-next button" href="/zio-prelude/docs/functionaldatatypes/these"><span>These</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#constructing-nonemptylist-values">Constructing NonEmptyList Values</a></li><li><a href="#working-with-nonemptylist-values">Working With NonEmptyList Values</a></li><li><a href="#interoperability-with-scala-collections">Interoperability With Scala Collections</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/zio/prelude/">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>