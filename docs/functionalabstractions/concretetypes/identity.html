<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Identity · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Identity[A]` describes a data type with an associative combining operation that also has an identity element."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Identity · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`Identity[A]` describes a data type with an associative combining operation that also has an identity element."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class=""><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Concrete Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concrete Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative">Associative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/commutative">Commutative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/equal">Equal</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash">Hash</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity">Identity</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse">Inverse</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord">Ord</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Parameterized Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeboth">AssociativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeeither">AssociativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeflatten">AssociativeFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeboth">CommutativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeeither">CommutativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant">Contravariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/covariant">Covariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach">ForEach</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityboth">IdentityBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither">IdentityEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityflatten">IdentityFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/invariant">Invariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/nonemptyforeach">NonEmptyForEach</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Identity</h1></header><article><div><span><p><code>Identity[A]</code> describes a data type with an associative combining operation that also has an identity element.</p>
<p>Its signature is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Associative</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">A</span>, right: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">A</span>
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Identity</span>[<span class="hljs-type">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">Associative</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identity</span></span>: <span class="hljs-type">A</span>
}
</code></pre>
<p>The identity element is a neutral value that does not have any structure itself and so combining it with any other value just leaves the structure of the other value unchanged. For instance, an empty <code>Chunk</code> is an identity element with respect to the <code>++</code> operator.</p>
<p>It is important to note here that while <code>Identity</code> describes a data type with an identity element, that identity element only has meaning in relation to the binary operator. Specifically, combining any value of type <code>A</code> with the identity element with the <code>combine</code> operator must return the value unchanged.</p>
<pre><code class="hljs css language-scala">a &lt;&gt; identity === a
identity &lt;&gt; a === a
</code></pre>
<p>For example, zero is an identity element with respect to addition, but not with respect to multiplication. Similarly, <code>true</code> is an identity element with respect to logical conjunction, but <code>false</code> is an identity element with respect to logical disjunction.</p>
<p>Many associative combinining operations also have an identity element, but some do not.</p>
<p>For example the minimum or maximum of two values on which a total ordering is defined does not have an identity element. Neither does the first or last of two values or the concatenation of collections that cannot be empty.</p>
<p>If we import <code>zio.prelude._</code> we can use the same <code>&lt;&gt;</code> operator as we did to combine two values for which an <code>Associative</code> instance was defined.</p>
<p>Since the <code>identity</code> value is a single value and not an operator we access it slightly different. Typically we will use the <code>apply</code> method on the <code>Identity</code> companion object.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._
<span class="hljs-keyword">import</span> zio.prelude.newtypes._

<span class="hljs-keyword">val</span> zero: <span class="hljs-type">Int</span> =
  <span class="hljs-type">Identity</span>[<span class="hljs-type">Sum</span>[<span class="hljs-type">Int</span>]].identity
<span class="hljs-comment">// zero: Int = 0</span>
</code></pre>
<p>The <code>apply</code> operator on the <code>Identity</code> companion object &quot;looks up&quot; the instance of the type class for the specified type, failing with a compilation error if the instance cannot be found. This operator is available on every functional abstraction in ZIO Prelude and is sometimes referred to as its &quot;summoner&quot;.</p>
<p>Notice also here that we are using the <code>Sum</code> new type to specify that we are interested in the identity element with respect to addition rather than another operator such as multiplication. See the section on new types in the documentation for the <code>Associative</code> abstraction for a discussion of the use of new types to disambiguate type class instances.</p>
<p>The main value the identity element adds over just having the associative combining operation is the ability to handle cases where we do not have any value of the type at all.</p>
<p>With the <code>Associative</code> abstraction we know how to combine any two values of type <code>A</code>. So if we have one or more values of type <code>A</code> we can always combine them all together by repeatedly applying the <code>combine</code> operator.</p>
<p>However, we need at least one <code>A</code> value to get the process started. If we don't have any <code>A</code> value initially we have no way to create one with the <code>Associative</code> abstraction alone.</p>
<p>To see this, consider the example of computing the minimum value in a collection.</p>
<p>If the collection has exactly one element we can just return it. And if it has more than one element we can combine them using the <code>min</code> operator until we only have a single value.</p>
<p>But what do we do if the collection has no values? We can't do anything so we return an <code>Option</code> that is a <code>Some</code> with the minimum if there is at least one element and <code>None</code> otherwise.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._
<span class="hljs-keyword">import</span> zio.prelude.newtypes._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span></span>[<span class="hljs-type">A</span>: <span class="hljs-type">Ord</span>](as: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =
  <span class="hljs-type">Max</span>.wrapAll(as) <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> h :: t =&gt; <span class="hljs-type">Some</span>(t.foldLeft(h)(_ &lt;&gt; _))
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>    =&gt; <span class="hljs-type">None</span>
  }
</code></pre>
<p>Compare this to computing the sum of a collection. Now If the collection is empty we can just return the identity value.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>[<span class="hljs-type">A</span>](as: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>])(<span class="hljs-keyword">implicit</span> identity: <span class="hljs-type">Identity</span>[<span class="hljs-type">Sum</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">A</span> =
  <span class="hljs-type">Sum</span>.wrapAll(as).foldLeft(identity.identity)(identity.combine(_, _))
</code></pre>
<p>The identity element handles the case where the collection is empty for us, allowing us to always return a summary value.</p>
<p>If we don't have an identity value we can only guarantee that we can return a summary value if the collection is known not to be empty, such as a <code>NonEmptyChunk</code> or a <code>NonEmptyList</code>. This is why these data types can be valuable.</p>
<p>If the collection could be empty and we only have a <code>combine</code> operator we may not be able to return a summary value and the best we can do is an <code>Option</code>.</p>
<p>One way to think of this is that the <code>None</code> case of the <code>Option</code> handles the possibility of failure. Another is that the <code>None</code> case of the <code>Option</code> provides the identity element for the <code>combine</code> operator, which we can express like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OptionIdentity</span></span>[<span class="hljs-type">A</span>: <span class="hljs-type">Associative</span>]: <span class="hljs-type">Identity</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Identity</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>], right: =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] =
      (left, right) <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(a1), <span class="hljs-type">Some</span>(a2)) =&gt; <span class="hljs-type">Some</span>(a1 &lt;&gt; a2)
        <span class="hljs-keyword">case</span> (_, <span class="hljs-type">None</span>)            =&gt; left
        <span class="hljs-keyword">case</span> (<span class="hljs-type">None</span>, _)            =&gt; right
        <span class="hljs-keyword">case</span> (_, _)               =&gt; <span class="hljs-type">None</span>
      }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identity</span></span>: <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">None</span>
  }
</code></pre>
<p>This says that we can define an <code>Identity</code> instance for any <code>Option[A]</code> as long as there is an <code>Associative</code> instance defined for <code>A</code>. The <code>Option</code> provides the &quot;free&quot; structure of an identity element to go from just having an associative <code>combine</code> operator to having an <code>identity</code> element.</p>
<p>This can be useful to keep in mind if you are dealing with a collection that could be empty and need an <code>Identity</code> instance but only have an <code>Associative</code> instance. You can always map your collection type to an <code>Option</code> and then you will have an <code>Identity</code> instance.</p>
<p>Data types with an associative <code>combine</code> operator and an <code>identity</code> element are very common. With an <code>Identity</code> instance defined for them and the other tools in ZIO Prelude you are in a good position to handle working with even complex data types.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash"><span class="arrow-prev">← </span><span>Hash</span></a><a class="docs-next button" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse"><span>Inverse</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/zio/prelude/">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>