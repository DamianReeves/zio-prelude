<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Equal · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Equal[A]` describes the ability to compare two values of type `A` for equality."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Equal · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`Equal[A]` describes the ability to compare two values of type `A` for equality."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class=""><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Concrete Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concrete Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative">Associative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/commutative">Commutative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug">Debug</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/equal">Equal</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash">Hash</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity">Identity</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse">Inverse</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord">Ord</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Parameterized Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeboth">AssociativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeeither">AssociativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeflatten">AssociativeFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeboth">CommutativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeeither">CommutativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant">Contravariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/covariant">Covariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach">ForEach</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityboth">IdentityBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither">IdentityEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityflatten">IdentityFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/invariant">Invariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/nonemptyforeach">NonEmptyForEach</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Equal</h1></header><article><div><span><p><code>Equal[A]</code> describes the ability to compare two values of type <code>A</code> for equality.</p>
<p>Its signature is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Equal</span>[-<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equal</span></span>(left: <span class="hljs-type">A</span>, right: <span class="hljs-type">A</span>): <span class="hljs-type">Boolean</span>
}
</code></pre>
<p>If we import <code>zio.prelude._</code> we can use the <code>===</code> and <code>!==</code> operators to compare any two values of type <code>A</code> for equality as long as there is an <code>Equal</code> instance defined for them.</p>
<p>This has several advantages over using the <code>==</code> and <code>!=</code> defined in the Scala standard library.</p>
<p>First, using <code>Equal</code> prevents bugs because it stops nonsensical code that attempts to compare unrelated types from compiling.</p>
<p>Using <code>==</code> we can compare any two values for equality, even if they are unrelated types. For example, this code has a bug.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SequenceNumber</span>(<span class="hljs-params">value: <span class="hljs-type">Int</span></span>)</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInitial</span></span>(sequenceNumber: <span class="hljs-type">SequenceNumber</span>): <span class="hljs-type">Boolean</span> =
  sequenceNumber == <span class="hljs-number">0</span>
<span class="hljs-comment">//</span>
</code></pre>
<p>We're trying to determine if this is the initial sequence number , but we're comparing the <code>sequenceNumber</code>, which is a <code>SequenceNumber</code>, with <code>0</code>, which is an <code>Int</code>. So this comparison will always be false even if the <code>sequenceNumber</code> is <code>SequenceNumber(0)</code> which is what we are trying to test for.</p>
<p>This snippet may generate a warning but it is still valid Scala code.</p>
<p>In contrast, ZIO Prelude's <code>Equal</code> abstraction catches the bug and prevents this code from even compiling.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SequenceNumber</span>(<span class="hljs-params">value: <span class="hljs-type">Int</span></span>)</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SequenceNumber</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">SequenceNumberEqual</span>: <span class="hljs-type">Equal</span>[<span class="hljs-type">SequenceNumber</span>] =
    <span class="hljs-type">Equal</span>.<span class="hljs-keyword">default</span>
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInitial</span></span>(sequenceNumber: <span class="hljs-type">SequenceNumber</span>): <span class="hljs-type">Boolean</span> =
  sequenceNumber === <span class="hljs-number">0</span>
<span class="hljs-comment">// error: No implicit Equal defined for Any.</span>
<span class="hljs-comment">//   sequenceNumber === 0</span>
<span class="hljs-comment">//   ^^^^^^^^^^^^^^^^^^^^</span>
</code></pre>
<p>To get the code to compile we have to fix the bug.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SequenceNumber</span>(<span class="hljs-params">value: <span class="hljs-type">Int</span></span>)</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SequenceNumber</span> </span>{

  <span class="hljs-keyword">val</span> initial: <span class="hljs-type">SequenceNumber</span> =
    <span class="hljs-type">SequenceNumber</span>(<span class="hljs-number">0</span>)

  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">SequenceNumberEqual</span>: <span class="hljs-type">Equal</span>[<span class="hljs-type">SequenceNumber</span>] =
    <span class="hljs-type">Equal</span>.<span class="hljs-keyword">default</span>
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isFirst</span></span>(sequenceNumber: <span class="hljs-type">SequenceNumber</span>): <span class="hljs-type">Boolean</span> =
  sequenceNumber === <span class="hljs-type">SequenceNumber</span>.initial
</code></pre>
<p>A second advantage is catching bugs when we try to compare two values of a type that doesn't have a meaningful notion of equality. For example, it doesn't make sense to compare two Scala functions for equality, but we can still do it with <code>==</code>.</p>
<p>In contrast, comparing two functions with <code>===</code> will result in a compilation error, preventing us from making this mistake.</p>
<p>A third advantage of the <code>Equal</code> abstraction is that it lets us use our own notion of equality for data types that are not under our control. We may be working with data types from other libraries that do not implement a reasonable notion of equality, for example using reference equality instead of value equality.</p>
<p>If we are using <code>==</code> we can't do anything about that because <code>==</code> is always based on how the data type implements <code>equals</code>. But if we are using <code>===</code> from ZIO Prelude we can define our own <code>Equal</code> instance that implements a more sensible notion of equality.</p>
<h2><a class="anchor" aria-hidden="true" id="defining-equal-instances"></a><a href="#defining-equal-instances" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Equal Instances</h2>
<p>Equal instances are automatically available for data types from the Scala library and ZIO with a meaningful notion of equality, as well as data types made up of those types.</p>
<p>We can always check if an instance of a type class exists for a given data type by using the <code>apply</code> operator to tell the Scala compiler to find the appropriate instance for us. This will result in a compilation error if the instance cannot be found.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Equal</span>[<span class="hljs-type">List</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]]]
<span class="hljs-comment">// res3: Equal[List[Either[String, Int]]] = zio.prelude.Equal$$anonfun$make$2@1aacf2d7</span>
</code></pre>
<pre><code class="hljs css language-scala"><span class="hljs-type">Equal</span>[<span class="hljs-type">String</span> =&gt; <span class="hljs-type">Int</span>]
<span class="hljs-comment">// error: No implicit Equal defined for String =&gt; Int.</span>
<span class="hljs-comment">// Equal[String =&gt; Int]</span>
<span class="hljs-comment">// ^^^^^^^^^^^^^^^^^^^^</span>
</code></pre>
<p>Defining <code>Equal</code> instances for your own data types is generally quite easy.</p>
<p>If you have already defined a sensible <code>equals</code> method for your data type then you can just use the <code>default</code> operator to construct an <code>Equal</code> instance as we saw in the example above involving the <code>SequenceNumber</code>.</p>
<p>Since the <code>SequenceNumber</code> is a case class it already has a well defined <code>equals</code> method as long as each value in the case class also has a well defined <code>equals</code> method. Equality for <code>Int</code> values is definitely well behaved so there is nothing we have to do here other than use the <code>default</code> operator.</p>
<p>If we don't want to use the default definition of equality we can use the <code>make</code> operator to define a new <code>Equal</code> instance based on our own definition of equality.</p>
<p>This is particularly useful if we are defining an <code>Equal</code> instance for a parameterized type and want to compare the types it is parameterized on for equality using their own <code>Equal</code> instances.</p>
<p>For example, say we have a class class to represent a pair of values.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](<span class="hljs-params">first: <span class="hljs-type">A</span>, second: <span class="hljs-type">B</span></span>)</span>
</code></pre>
<p>The <code>equals</code> method on a case class delegates to the <code>equals</code> method on each of its fields and we don't know if <code>A</code> or <code>B</code> have sensible definitions of <code>equals</code> since they are generic. So we want to instead define our own <code>Equal</code> instance directly like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Pair</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PairEqual</span></span>[<span class="hljs-type">A</span>: <span class="hljs-type">Equal</span>, <span class="hljs-type">B</span>: <span class="hljs-type">Equal</span>]: <span class="hljs-type">Equal</span>[<span class="hljs-type">Pair</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]] =
    <span class="hljs-type">Equal</span>.make { (left, right) =&gt;
      left.first === right.first &amp;&amp; left.second === right.second
    }
}
</code></pre>
<p>Notice how we had to require that <code>Equal</code> instances existed for <code>A</code> and <code>B</code>. We can't just compare any <code>Pair</code> for equality, we can only do it if each field of the pair can also be compared for equality.</p>
<p>Including <code>Equal</code> after the definition of the <code>A</code> and <code>B</code> type parameters here is called a <em>context</em> bound_ and is another way of saying that an implicit instance of <code>Equal[A]</code> and <code>Equal[B]</code> must exist. It can make our code a little cleaner when we don't need to do anything with the instance other than require that it exists, in this case for the <code>===</code> operator.</p>
<p>If we can convert our data type to another data type for which an <code>Equal</code> instance is already defined we can make this even simpler using the <code>contramap</code> operator.</p>
<p>In the example above, we can convert any <code>Pair</code> into a tuple without losing any information. And ZIO Prelude already defines an <code>Equal</code> instance for any tuple of data types for which <code>Equal</code> instances are defined.</p>
<p>So we can rewrite our implementation of <code>PairEqual</code> like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Pair</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PairEqual</span></span>[<span class="hljs-type">A</span>: <span class="hljs-type">Equal</span>, <span class="hljs-type">B</span>: <span class="hljs-type">Equal</span>]: <span class="hljs-type">Equal</span>[<span class="hljs-type">Pair</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]] =
    <span class="hljs-type">Equal</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)].contramap(pair =&gt; (pair.first, pair.second))
}
</code></pre>
<p>The <code>contramap</code> operator essentially says if we can compare two tuples for equality, and we can turn a pair into a tuple, then we can always compare two pairs for equality by turning them both into tuples and comparing the tuples for equality.</p>
<p>The <code>contramap</code> operator can be useful to create <code>Equal</code> instances from existing ones but the way we &quot;work backwards&quot; from the type we know how to compare for equality to the <code>Equal</code> instance we are trying to make can be confusing initially. So it is fine to just use the <code>make</code> operator as discussed above, which essentially does the same thing.</p>
<p>With the instances already defined for all types in ZIO and the Scala standard library with meaningful definitions of equality and the ability to define instances for your own data types with <code>make</code> and <code>contramap</code> it is easy to take advantage of the additional type safety that using <code>===</code> provides.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug"><span class="arrow-prev">← </span><span>Debug</span></a><a class="docs-next button" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash"><span>Hash</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#defining-equal-instances">Defining Equal Instances</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/zio/prelude/">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>