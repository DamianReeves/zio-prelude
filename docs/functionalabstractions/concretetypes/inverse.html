<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Inverse · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Inverse[A]` describes a type that has a `combine` operator and also has an `inverse` operator that is the inverse of the `combine` operator."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Inverse · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`Inverse[A]` describes a type that has a `combine` operator and also has an `inverse` operator that is the inverse of the `combine` operator."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class=""><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Concrete Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concrete Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative">Associative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/commutative">Commutative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/equal">Equal</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash">Hash</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity">Identity</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse">Inverse</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord">Ord</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Parameterized Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeboth">AssociativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeeither">AssociativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeflatten">AssociativeFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeboth">CommutativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeeither">CommutativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant">Contravariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/covariant">Covariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach">ForEach</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityboth">IdentityBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither">IdentityEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityflatten">IdentityFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/invariant">Invariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/nonemptyforeach">NonEmptyForEach</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Inverse</h1></header><article><div><span><p><code>Inverse[A]</code> describes a type that has a <code>combine</code> operator and also has an <code>inverse</code> operator that is the inverse of the <code>combine</code> operator.</p>
<p>Its signature is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Associative</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">A</span>, right: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">A</span>
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Identity</span>[<span class="hljs-type">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">Associative</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identity</span></span>: <span class="hljs-type">A</span>
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Inverse</span>[<span class="hljs-type">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">Identity</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inverse</span></span>(left: =&gt; <span class="hljs-type">A</span>, right: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">A</span>
}
</code></pre>
<p>For example, subtraction is an <code>inverse</code> operator with addition being the <code>combine</code> operator and <code>0</code> being the <code>identity</code> value.</p>
<p>While the <code>combine</code> operator adds structure, the <code>inverse</code> operator takes it away, undoing the structure that the <code>combine</code> operator added. As a result, applying the <code>inverse</code> operator to a value and itself takes away all the structure, returning the identity element.</p>
<pre><code class="hljs css language-scala">inverse(a, a) === identity
</code></pre>
<p>It is important to note that <code>inverse</code> is a binary operator rather than a unary operator.</p>
<p>When we think of an inverse with respect to integer addition it is tempting to think of the inverse as the unary operator of negation. This does indeed have the attractive property that the sum of any value and its inverse is zero.</p>
<p>However, this definition turns out to be quite limiting because it does not allow us to describe an inverse for types that do not contain negative values.</p>
<p>To see this, consider the case of natural numbers, represented by the <code>Natural</code> new type in ZIO Prelude. By definition there are no negative natural numbers and thus we cannot define a unary inverse operator for <code>Natural</code>.</p>
<p>However, natural numbers have a well defined notion of subtraction so it feels like we are missing something here. The solution is to view <code>inverse</code> as a binary operator.</p>
<p>We can then define an <code>Inverse</code> instance for <code>Natural</code> like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._
<span class="hljs-keyword">import</span> zio.prelude.newtypes._

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">NaturalInverse</span>: <span class="hljs-type">Inverse</span>[<span class="hljs-type">Natural</span>] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Inverse</span>[<span class="hljs-type">Natural</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">Natural</span>, right: =&gt; <span class="hljs-type">Natural</span>): <span class="hljs-type">Natural</span> =
      <span class="hljs-type">Natural</span>.plus(left, right)
    <span class="hljs-keyword">val</span> identity: <span class="hljs-type">Natural</span> =
      <span class="hljs-type">Natural</span>.zero
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inverse</span></span>(left: =&gt; <span class="hljs-type">Natural</span>, right: =&gt; <span class="hljs-type">Natural</span>): <span class="hljs-type">Natural</span> =
      <span class="hljs-type">Natural</span>.minus(left, right)
  }
<span class="hljs-comment">// NaturalInverse: Inverse[Natural] = repl.MdocSession$App0$$anon$1@47c19c83</span>
</code></pre>
<p>This also lets us define <code>Inverse</code> instances for other data types that we would not otherwise be able to. For example, what is the inverse of <code>Set(1, 2, 3)</code>?</p>
<p>Logically it is the set of all integers other than <code>1</code>, <code>2</code>, and <code>3</code> but we have no way of efficiently representing that because a <code>Set</code> is a collection of concrete values. So we would not be able to define an <code>Inverse</code> instance for <code>Set</code> this way.</p>
<p>On the other hand, by defining <code>Inverse</code> as a binary operator we can quite easily do so.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SetInverse</span></span>[<span class="hljs-type">A</span>]: <span class="hljs-type">Inverse</span>[<span class="hljs-type">Set</span>[<span class="hljs-type">A</span>]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Inverse</span>[<span class="hljs-type">Set</span>[<span class="hljs-type">A</span>]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>], right: =&gt; <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>] =
      left | right
    <span class="hljs-keyword">val</span> identity: <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>] =
      <span class="hljs-type">Set</span>.empty
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inverse</span></span>(left: =&gt; <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>], right: =&gt; <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Set</span>[<span class="hljs-type">A</span>] =
      left &amp;~ right
  }
</code></pre>
<p>The <code>inverse</code> operator is set difference, with the <code>combine</code> operator being set union and the empty set being the <code>identity</code> value.</p>
<p>The <code>inverse</code> abstraction tends to be used less frequently than the other abstractions for combining values. In writing programs, we typically want to build up more complex values from simpler ones, even if it is just tearing down one data type to build another.</p>
<p>The <code>Inverse</code> abstraction is most useful when we want to generalize over the notion of &quot;subtraction&quot; for different types. For example, if we are working with maps we might be interested in defining an operation that lets us return the difference between one map and another.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diff</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>: <span class="hljs-type">Equal</span> : <span class="hljs-type">Inverse</span>](left: <span class="hljs-type">Map</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>], right: <span class="hljs-type">Map</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Map</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =
  right.foldLeft(left) { <span class="hljs-keyword">case</span> (map, (a, b)) =&gt;
    <span class="hljs-keyword">val</span> b1 = <span class="hljs-type">Inverse</span>[<span class="hljs-type">B</span>].inverse(map.getOrElse(a, <span class="hljs-type">Identity</span>[<span class="hljs-type">B</span>].identity), b)
    <span class="hljs-keyword">if</span> (b1 === <span class="hljs-type">Identity</span>[<span class="hljs-type">B</span>].identity) map - a <span class="hljs-keyword">else</span> map + (a -&gt; b1)
  }
</code></pre>
<p>We look up the value for every key in the <code>right</code> map in the <code>left</code> map, returning the <code>identity</code> value if it does not exist. We then compute the difference using the <code>inverse</code> operator.</p>
<p>If the difference is equal to the <code>identity</code> value we remove the key from the map. Otherwise we add it.</p>
<p>Let's see it in action.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> peopleWhoOweMe: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Sum</span>[<span class="hljs-type">Int</span>]] =
  <span class="hljs-type">Map</span>(<span class="hljs-string">"Alice"</span> -&gt; <span class="hljs-type">Sum</span>(<span class="hljs-number">1000</span>), <span class="hljs-string">"Bob"</span> -&gt; <span class="hljs-type">Sum</span>(<span class="hljs-number">1000</span>))
<span class="hljs-comment">// peopleWhoOweMe: Map[String, Sum[Int]] = Map("Alice" -&gt; 1000, "Bob" -&gt; 1000)</span>

<span class="hljs-keyword">val</span> peopleIOwe: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Sum</span>[<span class="hljs-type">Int</span>]] =
  <span class="hljs-type">Map</span>(<span class="hljs-string">"Alice"</span> -&gt; <span class="hljs-type">Sum</span>(<span class="hljs-number">1000</span>), <span class="hljs-string">"Carol"</span> -&gt; <span class="hljs-type">Sum</span>(<span class="hljs-number">1000</span>))
<span class="hljs-comment">// peopleIOwe: Map[String, Sum[Int]] = Map("Alice" -&gt; 1000, "Carol" -&gt; 1000)</span>

<span class="hljs-keyword">val</span> myNetFinancialPosition: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] =
  diff(peopleWhoOweMe, peopleIOwe)
<span class="hljs-comment">// myNetFinancialPosition: Map[String, Int] = Map(</span>
<span class="hljs-comment">//   "Bob" -&gt; 1000,</span>
<span class="hljs-comment">//   "Carol" -&gt; -1000</span>
<span class="hljs-comment">// )</span>

<span class="hljs-keyword">val</span> friends: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">String</span>]] =
  <span class="hljs-type">Map</span>(<span class="hljs-string">"Alice"</span> -&gt; <span class="hljs-type">Set</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Carol"</span>), <span class="hljs-string">"Bob"</span> -&gt; <span class="hljs-type">Set</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Carol"</span>))
<span class="hljs-comment">// friends: Map[String, Set[String]] = Map(</span>
<span class="hljs-comment">//   "Alice" -&gt; Set("Bob", "Carol"),</span>
<span class="hljs-comment">//   "Bob" -&gt; Set("Alice", "Carol")</span>
<span class="hljs-comment">// )</span>

<span class="hljs-keyword">val</span> unfriends: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">String</span>]] =
  <span class="hljs-type">Map</span>(<span class="hljs-string">"Alice"</span> -&gt; <span class="hljs-type">Set</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Carol"</span>), <span class="hljs-string">"Bob"</span> -&gt; <span class="hljs-type">Set</span>(<span class="hljs-string">"Alice"</span>))
<span class="hljs-comment">// unfriends: Map[String, Set[String]] = Map(</span>
<span class="hljs-comment">//   "Alice" -&gt; Set("Bob", "Carol"),</span>
<span class="hljs-comment">//   "Bob" -&gt; Set("Alice")</span>
<span class="hljs-comment">// )</span>

<span class="hljs-keyword">val</span> updatedFriends: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Set</span>[<span class="hljs-type">String</span>]] =
  diff(friends, unfriends)
<span class="hljs-comment">// updatedFriends: Map[String, Set[String]] = Map("Bob" -&gt; Set("Carol"))</span>
</code></pre>
<p>In the first example the two maps represent assets and liabilities. The difference between them is our net financial position with each of our counterparties.</p>
<p>In the second example the first map represents the friends of users of a social networking site and the second represents friend removals for each user that need to be processed. The difference between them is the updated friends for each user we should return.</p>
<p>Often you won't need to use the <code>Inverse</code> abstraction directly. For example, functionality similar to the above is provided by the <code>ZSet</code> data type in ZIO Prelude.</p>
<p>However, when you do need to work some notion of subtraction <code>Inverse</code> is here and will let you describe that shared structure in a composable way.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity"><span class="arrow-prev">← </span><span>Identity</span></a><a class="docs-next button" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord"><span>Ord</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/index.html">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div></body></html>