<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Commutative · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Commutative[A]` describes a data type that has a `combine` operator that is commutative and associative."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Commutative · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`Commutative[A]` describes a data type that has a `combine` operator that is commutative and associative."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class=""><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Concrete Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concrete Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative">Associative</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/commutative">Commutative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/equal">Equal</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash">Hash</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity">Identity</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse">Inverse</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord">Ord</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Parameterized Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeboth">AssociativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeeither">AssociativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeflatten">AssociativeFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeboth">CommutativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeeither">CommutativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant">Contravariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/covariant">Covariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach">ForEach</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityboth">IdentityBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither">IdentityEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityflatten">IdentityFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/invariant">Invariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/nonemptyforeach">NonEmptyForEach</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Commutative</h1></header><article><div><span><p><code>Commutative[A]</code> describes a data type that has a <code>combine</code> operator that is commutative and associative.</p>
<p>Its signature is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Associative</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">A</span>, right: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">A</span>
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Commutative</span>[<span class="hljs-type">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">Associative</span>[<span class="hljs-type">A</span>]</span>
</code></pre>
<p>The <code>Commutative</code> abstraction does not define any additional operators beyond the <code>combine</code> operator defined by <code>Associative</code>. However, it does provide additional structure to the <code>combine</code> operator.</p>
<p>Specifically, it says that the <code>combine</code> operator is commutative in addition to being associative. This means that not only does the order of operations not matter, but the order in which we combine the values does not matter.</p>
<pre><code class="hljs css language-scala">a &lt;&gt; b === b &lt;&gt; a
</code></pre>
<p>Only some ways of combining that are associative are commutative.</p>
<p>For example, integer addition is both associative and commutative. <code>2 + 3</code> is the same as <code>3 + 2</code>.</p>
<p>On the other hand, string concatenation is associative but not commutative. <code>&quot;a&quot; + &quot;b&quot;</code> is not the same as <code>&quot;b&quot; + &quot;a&quot;</code>.</p>
<p>We can use the <code>Commutative</code> abstraction to specify at the type level whether one of our data types can be combined in a way that is associative and commutative or only associative. We can also test for it using the laws testing functionality provided by ZIO Prelude.</p>
<p>For example, here is how we could define and test a <code>Commutative</code> instance for a version of the <code>RunningAverage</code> data type that we discussed in the introduction to functional abstractions.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._
<span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.laws._

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunningAverage</span>(<span class="hljs-params">sum: <span class="hljs-type">Long</span>, count: <span class="hljs-type">Int</span></span>)</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">RunningAverage</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">RunningAverageCommutative</span>: <span class="hljs-type">Commutative</span>[<span class="hljs-type">RunningAverage</span>] =
    <span class="hljs-keyword">new</span> <span class="hljs-type">Commutative</span>[<span class="hljs-type">RunningAverage</span>] {
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span></span>(left: =&gt; <span class="hljs-type">RunningAverage</span>, right: =&gt; <span class="hljs-type">RunningAverage</span>): <span class="hljs-type">RunningAverage</span> =
        <span class="hljs-type">RunningAverage</span>(left.sum + right.sum, left.count + right.count)
    }
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">RunningAverageEqual</span>: <span class="hljs-type">Equal</span>[<span class="hljs-type">RunningAverage</span>] =
    <span class="hljs-type">Equal</span>.<span class="hljs-keyword">default</span>
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">RunningAverageSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultRunnableSpec</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spec</span> </span>= suite(<span class="hljs-string">"RunningAverageSpec"</span>) {
    testM(<span class="hljs-string">"commutative"</span>) {
      <span class="hljs-keyword">val</span> runningAverageGen = <span class="hljs-type">Gen</span>.anyLong.zipWith(<span class="hljs-type">Gen</span>.anyInt)(<span class="hljs-type">RunningAverage</span>(_, _))
      checkAllLaws(<span class="hljs-type">Commutative</span>)(runningAverageGen)
    }
  }
}
</code></pre>
<p>The main advantage of having a <code>Commutative</code> instance is that we don't have to worry about the order in which we combine values because we will get the same result no matter what.</p>
<p>To take a simple example, consider combining the values in a set.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fruits: <span class="hljs-type">Set</span>[<span class="hljs-type">String</span>] =
  <span class="hljs-type">Set</span>(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"banana"</span>)
<span class="hljs-comment">// fruits: Set[String] = Set("apple", "orange", "banana")</span>

<span class="hljs-keyword">val</span> ints: <span class="hljs-type">Set</span>[<span class="hljs-type">Int</span>] =
  <span class="hljs-type">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// ints: Set[Int] = Set(1, 2, 3)</span>

<span class="hljs-keyword">val</span> notCommutative: <span class="hljs-type">String</span> =
  fruits.foldLeft(<span class="hljs-string">""</span>)(_ + _)
<span class="hljs-comment">// notCommutative: String = "appleorangebanana"</span>

<span class="hljs-keyword">val</span> commutative: <span class="hljs-type">Int</span> =
  ints.foldLeft(<span class="hljs-number">0</span>)(_ + _)
<span class="hljs-comment">// commutative: Int = 6</span>
</code></pre>
<p>The order of values in a set is arbitrary. When we iterate over the values of a set we must do it in some order, and that order may be the same for a particular implementation of a set, but that is not something we can rely on.</p>
<p>As a result, the value of <code>notCommutative</code> is not well defined. It could be <code>&quot;applebananaorange&quot;</code>, <code>&quot;orangebananaapple&quot;</code>, <code>&quot;bananaorangeapple&quot;</code>, among others.</p>
<p>We have to be very careful in dealing with <code>notCommutative</code>. Either we must not use it at all or we must use it in very limited ways that will return the same result regardless of the order in which it was constructed (e.g. testing whether it contains the substring <code>&quot;apple&quot;</code>).</p>
<p>In contrast, the value of <code>commutative</code> is extremely well defined. It will always be <code>6</code> no matter what.</p>
<p>Regardless of the order in which we iterate over the elements in the set it will always be <code>6</code> because addition is a commutative operation. Even if we tried to get a different value we couldn't come up with an order of iterating over the set elements that gave a different result.</p>
<p>Thus, we can safely work with <code>commutative</code> and do anything we want with it because it will always have the same value.</p>
<p>This is a simple example but this property of commutativity can come up in much more complex domains such as concurrent or distributed programming. There, the order in which we receive values from other fibers or nodes is often arbitrary.</p>
<p>In that case having a way of combining values that is commutative can be very useful because it means we don't need coordination mechanisms to ensure that we combine results in a certain order.</p>
<p>For an example of this we can look to the <code>mergeAllPar</code> operator on <code>ZIO</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ZIO</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeAllPar</span></span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](
    in: <span class="hljs-type">Iterable</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>]]
  )(zero: <span class="hljs-type">B</span>)(f: (<span class="hljs-type">B</span>, <span class="hljs-type">A</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">B</span>] =
    ???
}
</code></pre>
<p>This runs all of the <code>ZIO</code> workflows in the <code>Iterable</code> in parallel and combines their results with the function <code>f</code>, starting from <code>zero</code>. Its implementation creates a <code>Ref</code> with the <code>zero</code> value and then each fiber updates the <code>Ref</code> with its result as it completes.</p>
<p>The order in which the fibers complete is not determinate so the function <code>f</code> should be associative and commutative, as the documentation for <code>mergeAllPar</code> helpfully informs us.</p>
<p>We do not want to force functional abstractions on users so in ZIO itself we state that the function must satisfy these properties and leave it at that. But with ZIO Prelude we can define a version of this operator that expresses at the type level that the <code>combine</code> operator must be associative and commutative.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeAllParCommutative</span></span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>: <span class="hljs-type">Commutative</span>](
  in: <span class="hljs-type">Iterable</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>]]
)(zero: <span class="hljs-type">B</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">B</span>] =
  <span class="hljs-type">ZIO</span>.mergeAllPar(in)(zero)((b, a) =&gt; b &lt;&gt; f(a))
</code></pre>
<p>Now we run all the <code>ZIO</code> workflows in parallel, mapping their results to a type for which a commutative <code>combine</code> operator is defined. This will ensure that our way of combining values really is commutative.</p>
<p>With the <code>Commutative</code> abstraction we can describe the properties of our data types precisely, helping us understand what guarantees they provide and what our responsibilities are for working with them. This idea of commutative operators is also a helpful one to keep in mind when we are designing our own data types as we saw in the example above.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative"><span class="arrow-prev">← </span><span>Associative</span></a><a class="docs-next button" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug"><span>Debug</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/zio/prelude/">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div></body></html>