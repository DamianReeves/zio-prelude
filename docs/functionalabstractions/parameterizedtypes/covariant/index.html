<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Covariant · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Covariant[F]` describes a parameterized type `F[A]` that potentially produces but never consumes `A` values."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Covariant · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`Covariant[F]` describes a parameterized type `F[A]` that potentially produces but never consumes `A` values."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class=""><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Parameterized Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concrete Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative">Associative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/commutative">Commutative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/equal">Equal</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash">Hash</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity">Identity</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse">Inverse</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord">Ord</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Parameterized Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeboth">AssociativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeeither">AssociativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeflatten">AssociativeFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeboth">CommutativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeeither">CommutativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant">Contravariant</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/covariant">Covariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach">ForEach</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityboth">IdentityBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither">IdentityEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityflatten">IdentityFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/invariant">Invariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/nonemptyforeach">NonEmptyForEach</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Covariant</h1></header><article><div><span><p><code>Covariant[F]</code> describes a parameterized type <code>F[A]</code> that potentially produces but never consumes <code>A</code> values.</p>
<p>Its signature is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Invariant</span>[<span class="hljs-type">F</span>[_]] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> &lt;=&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] &lt;=&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Covariant</span>[<span class="hljs-type">F</span>[+_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">Invariant</span>[<span class="hljs-type">F</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> &lt;=&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] &lt;=&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>] =
    <span class="hljs-type">Equivalence</span>(map(f.to), map(f.from))
}

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">&lt;=&gt;</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] </span>= <span class="hljs-type">Equivalence</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Equivalence</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](<span class="hljs-params">to: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>, from: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span></span>)</span>
</code></pre>
<p>The <code>map</code> operator says we can &quot;lift&quot; a function <code>A =&gt; B</code> to a function <code>F[A] =&gt; F[B]</code>. If we import <code>zio.prelude._</code> we can use the <code>map</code> operator to transform an <code>F[A]</code> into an <code>F[B]</code> with a function <code>A =&gt; B</code>.</p>
<p>The law is that the lifting of this function can transform <code>A</code> values into <code>B</code> values but cannot otherwise change the structure of <code>F</code>, so using <code>map</code> with the identity function is an identity and separately using <code>map</code> with two functions is the same as doing it with the composition of those functions.</p>
<pre><code class="hljs css language-scala">fa.map(identity) === fa
fa.map(f).map(g) === fa.map(f.andThen(g))
</code></pre>
<p>Data types that are covariant may either contain zero or more existing <code>A</code> values, such as a <code>Chunk</code>, or potentially produce zero or more <code>A</code> values at some point in the future, such as a <code>ZIO</code>.</p>
<p>In the definition of <code>Covariant</code> above you may notice that a <code>+</code> appears before the <code>_</code>. This tells the Scala compiler that the parameterized type is covariant with respect to this type parameter.</p>
<p>This improves type inference because it allows the Scala compiler to automatically widen an <code>F[A]</code> to an <code>F[B]</code> if <code>A</code> is a subtype of <code>B</code> because a data type that outputs <code>A</code> values also outputs <code>B</code> values by definition. It also allows the Scala compiler to check for us that types for which we define a <code>Covariant</code> instance really are covariant with respect to their type parameters.</p>
<p>Other functional programming libraries do not take advantage of Scala's support for variance here and so have to resort to a <code>widen</code> operator that essentially amounts to mapping with the identity function.</p>
<p>Often data types that appear to be invariant are actually versions of more polymorphic data types that are covariant with respect to one or more of their type parameters. Generalizing these data types can lead to improved API design and allow defining additional operators.</p>
<p>Let's see these ideas in action with the <code>JsonCodec</code> data type.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">JsonCodec</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(json: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">A</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">String</span>
}
</code></pre>
<p>The <code>JsonCodec</code> data type is naturally invariant in the <code>A</code> type parameter because <code>A</code> appears as both an input to <code>encode</code> and an output from <code>decode</code>. As a result, the <code>A</code> type parameter appears in the definition of <code>JsonCodec</code> without a <code>+</code> or <code>-</code>.</p>
<p>Let's try adding a <code>+</code> before the <code>A</code> type parameter to indicate that <code>JsonCodec</code> is covariant with respect to this type parameter.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">JsonCodec</span>[+<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(json: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">A</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">String</span>
}
<span class="hljs-comment">// error: covariant type A occurs in contravariant position in type A of value a</span>
<span class="hljs-comment">//   def encode(a: A): String</span>
<span class="hljs-comment">//              ^^^^</span>
</code></pre>
<p>This code does not compile!</p>
<p>The Scala compiler helpfully informs us that the covariant type <code>A</code> appears in contravariant position in the <code>encode</code> operator. Translating slightly, the Scala compiler is telling us that we are not honoring the guarantee of <code>A</code> being covariant that <code>A</code> is an output but never an input because <code>A</code> appears as an input to <code>encode</code>.</p>
<p>Whenever we have to make a type invariant because <code>A</code> is both an input and an output we should ask ourselves whether it is possible to split that up. We can do that either by using different type parameters for the input and output or by refactoring to create separate interfaces where <code>A</code> only appears as an input or output.</p>
<p>Here we will take the second approach and split the <code>JsonCodec</code> up into a <code>JsonDecoder</code> and a <code>JsonEncoder</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">JsonDecoder</span>[+<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(json: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">A</span>]
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">JsonEncoder</span>[-<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">String</span>
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">JsonCodec</span>[<span class="hljs-type">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonDecoder</span>[<span class="hljs-type">A</span>] <span class="hljs-keyword">with</span> <span class="hljs-title">JsonEncoder</span>[<span class="hljs-type">A</span>]</span>
</code></pre>
<p>Now <code>A</code> only appears as an output of the <code>JsonEncoder</code> and only appears as an input of <code>JsonDecoder</code> and we can make <code>A</code> covariant by using the <code>+</code> before the type parameter. We can also make <code>JsonEncoder</code> contravariant, but we will defer discussion of that to the section on the <code>Contravariant</code> functional abstraction.</p>
<p>With the <code>JsonDecoder</code> and <code>JsonEncoder</code> separated out, we can now define a <code>Covariant</code> instance for the <code>JsonDecoder</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">JsonDecoder</span>[+<span class="hljs-type">A</span>] </span>{ self =&gt;
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(json: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">A</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">JsonDecoder</span>[<span class="hljs-type">B</span>] =
    <span class="hljs-keyword">new</span> <span class="hljs-type">JsonDecoder</span>[<span class="hljs-type">B</span>] {
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(json: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">B</span>] =
        self.decode(json).map(f)
    }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">JsonDecoder</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">JsonDecoderCovariant</span>: <span class="hljs-type">Covariant</span>[<span class="hljs-type">JsonDecoder</span>] =
    <span class="hljs-keyword">new</span> <span class="hljs-type">Covariant</span>[<span class="hljs-type">JsonDecoder</span>] {
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">JsonDecoder</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">JsonDecoder</span>[<span class="hljs-type">B</span>] =
        jsonDecoder =&gt; jsonDecoder.map(f)
    }
}
</code></pre>
<p>In addition to being able to define a <code>Covariant</code> instance, we have improved our API design by recognizing that our definition of <code>JsonCodec</code> was actually combining two things that are conceptually distinct. Now users can work with just a <code>Decoder</code> if all they are doing is reading data and it is easier to transform a decoder because we only need to provide a function and not an equivalence relationship.</p>
<p>The <code>map</code> operator is extremely useful and you are probably familiar with it from a variety of data types in the Scala standard library and ZIO. However, the <code>map</code> operator is already defined directly on most data types that support it.</p>
<p>As a result, the <code>Covariant</code> abstraction tends to be useful in two ways.</p>
<p>First, defining a <code>Covariant</code> instance for your own data type allows it to work with other operators in ZIO Prelude that require a data type to be covariant.</p>
<p>There are only a few operators that are defined for a data type that only has a <code>Covariant</code> instance but there are many more that we will learn about later that require a <code>Covariant</code> instance as well as some other instance. So defining an instance of <code>Covariant</code>, as well as whatever other functional abstractions are defined for your date type, is a good practice so that you can use any of these operators for your data type if you need to.</p>
<p>Second, <code>Covariant</code> can be useful if you are writing your own generic code since many generic operators you may want to define will require a <code>Covariant</code> instance. In particular, having a <code>Covariant</code> instance as well as an instance of one of the abstractions that describe ways to combine parameterized types allow many interesting operators to be defined.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant"><span class="arrow-prev">← </span><span>Contravariant</span></a><a class="docs-next button" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach"><span class="function-name-prevnext">ForEach</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/zio/prelude/">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div></body></html>