<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>IdentityBoth · ZIO Prelude</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`IdentityBoth[F]` describes an associative way to combine two values `F[A]` and `F[B]` into a value `F[(A, B)]` that also has an identity element of type `F[Any]`."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="IdentityBoth · ZIO Prelude"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-prelude/"/><meta property="og:description" content="`IdentityBoth[F]` describes an associative way to combine two values `F[A]` and `F[B]` into a value `F[(A, B)]` that also has an identity element of type `F[Any]`."/><meta property="og:image" content="https://zio.github.io/zio-prelude/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://zio.github.io/zio-prelude/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/zio-prelude/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-prelude/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-prelude/css/main.css"/><script src="/zio-prelude/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-prelude/"><img class="logo" src="/zio-prelude/img/navbar_brand2x.png" alt="ZIO Prelude"/><h2 class="headerTitleWithLogo">ZIO Prelude</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zio-prelude/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/zio-prelude/docs/functionalabstractions/" target="_self">Functional Abstractions</a></li><li class=""><a href="/zio-prelude/docs/functionaldatatypes/" target="_self">Functional Data Types</a></li><li class=""><a href="/zio-prelude/docs/newtypes/" target="_self">New Types</a></li><li class=""><a href="/zio-prelude/docs/zpure/" target="_self">ZPure</a></li><li class=""><a href="/zio-prelude/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/zio-prelude/docs/about/about_index" target="_self">About</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Parameterized Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concrete Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/associative">Associative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/commutative">Commutative</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/equal">Equal</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/hash">Hash</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/identity">Identity</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/inverse">Inverse</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/concretetypes/ord">Ord</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Parameterized Types</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeboth">AssociativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeeither">AssociativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/associativeflatten">AssociativeFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeboth">CommutativeBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/commutativeeither">CommutativeEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/contravariant">Contravariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/covariant">Covariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach">ForEach</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityboth">IdentityBoth</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither">IdentityEither</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityflatten">IdentityFlatten</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/invariant">Invariant</a></li><li class="navListItem"><a class="navItem" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/nonemptyforeach">NonEmptyForEach</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">IdentityBoth</h1></header><article><div><span><p><code>IdentityBoth[F]</code> describes an associative way to combine two values <code>F[A]</code> and <code>F[B]</code> into a value <code>F[(A, B)]</code> that also has an identity element of type <code>F[Any]</code>.</p>
<p>Its signature is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AssociativeBoth</span>[<span class="hljs-type">F</span>[_]] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">both</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">A</span>], fb: =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">F</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)]
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">IdentityBoth</span>[<span class="hljs-type">F</span>[_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">AssociativeBoth</span>[<span class="hljs-type">F</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">any</span></span>: <span class="hljs-type">F</span>[<span class="hljs-type">Any</span>]
}
</code></pre>
<p>The <code>any</code> value must be an identity element with respect to the <code>both</code> operator, so that after removing unnecessary tuples the following property holds:</p>
<pre><code class="hljs css language-scala">fa &lt;*&gt; identity === fa
identity &lt;*&gt; fa === fa
</code></pre>
<p>This is the same as the laws for the <code>Identity</code> functional abstraction for concrete types except lifted into the context of parameterized types.</p>
<p>To be an identity element, running the <code>any</code> value must not do anything so we can always compose it as many times as we want with the <code>both</code> operator without changing the result.</p>
<p>As with the other abstractions for parameterized types we have looked at <code>ZIO</code> provides a good initial example.</p>
<p>The <code>any</code> value for <code>ZIO</code> is <code>unit</code>, the workflow that does not do anything, always succeeds, and produces no useful information. We can do nothing before or after another <code>ZIO</code> workflow as many times as we want and we will always get a workflow that does the same thing.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.console._

<span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>

<span class="hljs-keyword">val</span> helloUnit: <span class="hljs-type">ZIO</span>[<span class="hljs-type">Console</span>, <span class="hljs-type">IOException</span>, (<span class="hljs-type">Unit</span>, <span class="hljs-type">Unit</span>)] =
  console.putStrLn(<span class="hljs-string">"Hello"</span>) &lt;*&gt; <span class="hljs-type">ZIO</span>.unit
<span class="hljs-comment">// helloUnit: ZIO[Console, IOException, (Unit, Unit)] = zio.ZIO$FlatMap@4296a04</span>

<span class="hljs-keyword">val</span> unitHello: <span class="hljs-type">ZIO</span>[<span class="hljs-type">Console</span>, <span class="hljs-type">IOException</span>, (<span class="hljs-type">Unit</span>, <span class="hljs-type">Unit</span>)] =
  <span class="hljs-type">ZIO</span>.unit &lt;*&gt; console.putStrLn(<span class="hljs-string">"Hello"</span>)
<span class="hljs-comment">// unitHello: ZIO[Console, IOException, (Unit, Unit)] = zio.ZIO$FlatMap@7a6eada2</span>
</code></pre>
<p>These programs are identical because <code>ZIO.unit</code> does not do anything at all and always succeeds.</p>
<p>Similarly, the <code>any</code> with respect to data types such as <code>Either</code> and <code>Option</code> that model failure is a successful value that contains no useful information.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> anyEither: <span class="hljs-type">Either</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">Any</span>] =
  <span class="hljs-type">Right</span>(())
<span class="hljs-comment">// anyEither: Either[Nothing, Any] = Right(value = ())</span>

<span class="hljs-keyword">val</span> anyOption: <span class="hljs-type">Option</span>[<span class="hljs-type">Any</span>] =
  <span class="hljs-type">Some</span>(())
<span class="hljs-comment">// anyOption: Option[Any] = Some(value = ())</span>
</code></pre>
<p>Since the <code>both</code> operator for these data types corresponds to failing on the first error or returning a success with all the results, the <code>any</code> value can never change the result. If <code>any</code> is combined with a failed value the result will be that failure, and if it is combined with a successful value the result will be that success.</p>
<p>For collection types the <code>any</code> value is a collection with a single value containing no useful information.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> anyList: <span class="hljs-type">List</span>[<span class="hljs-type">Any</span>] =
  <span class="hljs-type">List</span>(())
<span class="hljs-comment">// anyList: List[Any] = List(())</span>
</code></pre>
<p>We might be tempted to think that an empty collection would be the identity value but we can see this is not the case because the <code>both</code> operator corresponds to the Cartesian product of two collections and the product of a collection with the empty collection is the empty collection, not the original collection.</p>
<p>If we think of a collection as representing a set of possible states then we can think of this as the state that occurs with certainty. Or if we think of the <code>both</code> operator as being the product of two collections the identity element for multiplication is one, not zero.</p>
<p>For a parser the identity element would be a parser that always succeeds with no useful information and does not change the parse state.</p>
<p>We can also define identity values with respect to contravariant types.</p>
<p>For example, consider the <code>Predicate</code> data type.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Predicate</span>[-<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">Boolean</span>
}
</code></pre>
<p>We could define an <code>IdentityBoth</code> instance for it like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.prelude._

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Predicate</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">PredicateIdentityBoth</span>: <span class="hljs-type">IdentityBoth</span>[<span class="hljs-type">Predicate</span>] =
    <span class="hljs-keyword">new</span> <span class="hljs-type">IdentityBoth</span>[<span class="hljs-type">Predicate</span>] {
      <span class="hljs-keyword">val</span> any: <span class="hljs-type">Predicate</span>[<span class="hljs-type">Any</span>] =
        <span class="hljs-keyword">new</span> <span class="hljs-type">Predicate</span>[<span class="hljs-type">Any</span>] {
          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(a: <span class="hljs-type">Any</span>) =
            <span class="hljs-literal">true</span>
        }
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">both</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](left: =&gt; <span class="hljs-type">Predicate</span>[<span class="hljs-type">A</span>], right: =&gt; <span class="hljs-type">Predicate</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">Predicate</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)] =
        <span class="hljs-keyword">new</span> <span class="hljs-type">Predicate</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)] {
          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(tuple: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)): <span class="hljs-type">Boolean</span> =
            left.run(tuple._1) &amp;&amp; right.run(tuple._2)
        }
    }
}
</code></pre>
<p>The <code>both</code> operator for <code>Predicate</code> combines two predicates to return a new predicate that is true if both of the original predicates are true. So we can always combine any predicate with the predicate that is always true without changing the result.</p>
<p>This again shows the value of separating abstractions for defining how parameterized types can be combined from abstractions for describing their variance. Otherwise we would face a proliferation of abstractions to describe the product of these various combinations of properties of the combining operation and the variance of the data type, as other functional programming libraries have experienced.</p>
<p>When a data type has both a <code>IdentityBoth</code> and a <code>Covariant</code> instance we can define a particularly useful operator for it called <code>succeed</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">succeed</span></span>[<span class="hljs-type">F</span>[+_]: <span class="hljs-type">IdentityBoth</span> : <span class="hljs-type">Covariant</span>, <span class="hljs-type">A</span>](a: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =
  <span class="hljs-type">IdentityBoth</span>[<span class="hljs-type">F</span>].any.map(_ =&gt; a)
</code></pre>
<p>This says that if a data type is also covariant we can always &quot;lift&quot; any value into the data type by starting with the identity value and using <code>map</code> to transform the output type to the specified value.</p>
<p>This is very useful for working with parameterized data types in general because it allows us to take ordinary values and use them in the context of our parameterized type.</p>
<p>For example we can use the <code>succeed</code> operator on <code>ZIO</code> to wrap any arbitrary block of Scala code in a <code>ZIO</code> effect.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> helloScala: <span class="hljs-type">ZIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">Unit</span>] =
  <span class="hljs-type">ZIO</span>.succeed(println(<span class="hljs-string">"Hello, Scala!"</span>))
<span class="hljs-comment">// helloScala: ZIO[Any, Nothing, Unit] = zio.ZIO$EffectTotal@22b883c3</span>
</code></pre>
<p>This is also quite useful in ZIO Prelude in particular because many operators are only defined for data types that have an <code>IdentityBoth</code> instance, such as the <code>forEach</code> operator on the <code>ForEach</code> abstraction.</p>
<p>As with concrete data types, it is quite useful to have an identity element with respect to the combining operator for parameterized types.</p>
<p>Most of the time for working with existing data types from ZIO or the Scala standard library it will be less important directly because operators for that data type will already be defined for you.</p>
<p>However, it can still be helpful to think about what the identity value is with respect to a given operation. For example, you may not have thought of a <code>Right</code> with no useful information as being an identity with respect to combining <code>Either</code> values.</p>
<p>When defining your own parameterized data types, it can be helpful to think about whether an identity element exists with respect to combining values of your data type. If not, could it be refactored to have such an identity value, or does thinking about that tell you something about why it makes sense that your data type does not have one?</p>
<p>Finally, if you are writing generic code in terms of the functional abstractions in ZIO Prelude this is likely to be another important abstraction. In particular the ability to lift a value into the parameterized type described by the combination of the <code>CommutativeBoth</code> and <code>Covariant</code> abstractions is often important.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/foreach"><span class="arrow-prev">← </span><span class="function-name-prevnext">ForEach</span></a><a class="docs-next button" href="/zio-prelude/docs/functionalabstractions/parameterizedtypes/identityeither"><span class="function-name-prevnext">IdentityEither</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/zio-prelude/" class="nav-home"><img src="/zio-prelude/img/sidebar_brand2x.png" alt="ZIO Prelude"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-prelude" data-icon="octicon-star" data-count-href="/zio/zio-prelude/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="/zio-prelude//img/discord.png" width="120" alt="discord"/></a></div><div><h5>Additional resources</h5><a href="/zio-prelude/api/zio/prelude/">Scaladoc of zio-prelude</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>